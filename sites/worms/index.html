<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modular Flow Fields</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #0a0a0a;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function ModularFlowField() {
            const canvasRef = useRef(null);
            const animationRef = useRef(null);
            const particlesRef = useRef([]);
            const timeRef = useRef(0);
            const fieldRef = useRef(null);

            class Particle {
                constructor(x, y, canvas) {
                    this.x = x;
                    this.y = y;
                    this.canvas = canvas;
                    this.age = 0;
                    this.maxAge = 200 + Math.random() * 100;
                    this.trail = [];
                    this.trailLength = 25;
                }

                update(field, time) {
                    // Get flow vector from field
                    const gridX = Math.floor(this.x / field.resolution);
                    const gridY = Math.floor(this.y / field.resolution);
                    
                    if (gridX >= 0 && gridX < field.cols && gridY >= 0 && gridY < field.rows) {
                        const index = gridY * field.cols + gridX;
                        const vector = field.vectors[index];
                        
                        // Update position based on flow
                        this.x += vector.x * 0.8;
                        this.y += vector.y * 0.8;
                        
                        // Add small perturbation based on position for organic movement
                        const perturbation = Math.sin(this.x * 0.01 + time) * 0.1;
                        this.y += perturbation;
                    }
                    
                    // Store trail
                    this.trail.push({x: this.x, y: this.y});
                    if (this.trail.length > this.trailLength) {
                        this.trail.shift();
                    }
                    
                    this.age++;
                    
                    // Wrap around edges or respawn if too old
                    if (this.x < 0 || this.x > this.canvas.width || 
                        this.y < 0 || this.y > this.canvas.height || 
                        this.age > this.maxAge) {
                        this.respawn();
                    }
                }
                
                respawn() {
                    this.x = Math.random() * this.canvas.width;
                    this.y = Math.random() * this.canvas.height;
                    this.age = 0;
                    this.trail = [];
                }
                
                draw(ctx) {
                    // Draw trail with fading
                    for (let i = 0; i < this.trail.length - 1; i++) {
                        const point = this.trail[i];
                        const nextPoint = this.trail[i + 1];
                        const alpha = (i / this.trail.length) * 0.15 * (1 - this.age / this.maxAge);
                        
                        ctx.strokeStyle = `rgba(220, 220, 220, ${alpha})`;
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(point.x, point.y);
                        ctx.lineTo(nextPoint.x, nextPoint.y);
                        ctx.stroke();
                    }
                }
            }

            class FlowField {
                constructor(width, height, resolution) {
                    this.width = width;
                    this.height = height;
                    this.resolution = resolution;
                    this.cols = Math.ceil(width / resolution);
                    this.rows = Math.ceil(height / resolution);
                    this.vectors = new Array(this.cols * this.rows);
                    this.primes = [11, 13, 17, 19, 23];
                    this.primePhase = 0;
                }
                
                update(time) {
                    // Slowly rotate through different prime combinations
                    this.primePhase = time * 0.15;
                    
                    // Calculate interpolated primes
                    const p1 = this.primes[0] + Math.sin(this.primePhase) * 2;
                    const p2 = this.primes[1] + Math.cos(this.primePhase * 0.7) * 3;
                    const p3 = this.primes[2] + Math.sin(this.primePhase * 0.5) * 2;
                    
                    for (let y = 0; y < this.rows; y++) {
                        for (let x = 0; x < this.cols; x++) {
                            const index = y * this.cols + x;
                            
                            // Map grid coordinates to mathematical space
                            const mx = x - this.cols / 2;
                            const my = y - this.rows / 2;
                            
                            // Calculate modular values for field direction
                            const mod1 = ((mx * my) % p1 + p1) % p1;
                            const mod2 = ((mx * mx - my * my) % p2 + p2) % p2;
                            const mod3 = ((mx + my) * (mx + my) % p3 + p3) % p3;
                            
                            // Combine modular values to create flow angle
                            const angle = (mod1 / p1 + mod2 / p2 * 2 + mod3 / p3 * 3) * Math.PI * 2;
                            
                            // Create flow vector with magnitude based on position
                            const magnitude = 1 + Math.sin(Math.sqrt(mx * mx + my * my) * 0.05 + time) * 0.3;
                            
                            this.vectors[index] = {
                                x: Math.cos(angle) * magnitude,
                                y: Math.sin(angle) * magnitude
                            };
                        }
                    }
                }
                
                draw(ctx) {
                    // Draw field vectors as subtle indicators
                    ctx.strokeStyle = 'rgba(80, 80, 90, 0.08)';
                    ctx.lineWidth = 0.5;
                    
                    const step = 3; // Draw every nth vector for performance
                    for (let y = 0; y < this.rows; y += step) {
                        for (let x = 0; x < this.cols; x += step) {
                            const index = y * this.cols + x;
                            const vector = this.vectors[index];
                            
                            if (vector) {
                                const px = x * this.resolution;
                                const py = y * this.resolution;
                                
                                ctx.beginPath();
                                ctx.moveTo(px, py);
                                ctx.lineTo(
                                    px + vector.x * this.resolution * 0.3,
                                    py + vector.y * this.resolution * 0.3
                                );
                                ctx.stroke();
                            }
                        }
                    }
                }
            }

            useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                
                const resize = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    
                    // Recreate field on resize
                    fieldRef.current = new FlowField(canvas.width, canvas.height, 15);
                    
                    // Initialize particles
                    particlesRef.current = [];
                    const particleCount = Math.min(800, (canvas.width * canvas.height) / 1000);
                    for (let i = 0; i < particleCount; i++) {
                        particlesRef.current.push(new Particle(
                            Math.random() * canvas.width,
                            Math.random() * canvas.height,
                            canvas
                        ));
                    }
                };
                
                resize();
                window.addEventListener('resize', resize);

                const draw = () => {
                    const width = canvas.width;
                    const height = canvas.height;
                    
                    // Clear with subtle fade
                    ctx.fillStyle = 'rgba(10, 10, 10, 0.02)';
                    ctx.fillRect(0, 0, width, height);
                    
                    timeRef.current += 0.01;
                    const time = timeRef.current;
                    
                    // Update flow field
                    fieldRef.current.update(time);
                    
                    // Draw field vectors (optional, subtle)
                    if (Math.sin(time * 0.1) > 0.8) {
                        fieldRef.current.draw(ctx);
                    }
                    
                    // Update and draw particles
                    particlesRef.current.forEach(particle => {
                        particle.update(fieldRef.current, time);
                        particle.draw(ctx);
                    });
                    
                    animationRef.current = requestAnimationFrame(draw);
                };
                
                draw();
                
                return () => {
                    window.removeEventListener('resize', resize);
                    if (animationRef.current) {
                        cancelAnimationFrame(animationRef.current);
                    }
                };
            }, []);

            return (
                <div className="relative w-screen h-screen bg-black">
                    <canvas 
                        ref={canvasRef}
                        className="absolute inset-0"
                    />
                    <div className="absolute bottom-4 left-4 text-gray-700 text-xs font-mono opacity-30">
                        modular flow field: (x·y) mod p
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ModularFlowField />);
    </script>
</body>
</html>