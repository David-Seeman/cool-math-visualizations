<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Harmonic Resonance Field</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React Libraries -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel for JSX transpilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- MathJax for rendering the formula -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        /* Simple styling for the range inputs for better browser consistency */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }

        input[type="range"]:hover {
            opacity: 1;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            border: 2px solid;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            border: 2px solid;
        }

        .accent-purple-500::-webkit-slider-thumb { border-color: #a855f7; }
        .accent-purple-500::-moz-range-thumb { border-color: #a855f7; }

        .accent-blue-500::-webkit-slider-thumb { border-color: #3b82f6; }
        .accent-blue-500::-moz-range-thumb { border-color: #3b82f6; }

        .accent-green-500::-webkit-slider-thumb { border-color: #22c55e; }
        .accent-green-500::-moz-range-thumb { border-color: #22c55e; }

        .accent-orange-500::-webkit-slider-thumb { border-color: #f97316; }
        .accent-orange-500::-moz-range-thumb { border-color: #f97316; }
    </style>
</head>
<body class="bg-black">
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useRef } = React;

      const HarmonicResonanceField = () => {
        const canvasRef = useRef(null);
        const animationRef = useRef(null);
        const [frequency1, setFrequency1] = useState(3);
        const [frequency2, setFrequency2] = useState(5);
        const [amplitude, setAmplitude] = useState(0.5);
        const [speed, setSpeed] = useState(1);
        const [showControls, setShowControls] = useState(true);

        useEffect(() => {
          const canvas = canvasRef.current;
          if (!canvas) return;

          const ctx = canvas.getContext('2d');
          let width = canvas.width = window.innerWidth;
          let height = canvas.height = window.innerHeight;

          const handleResize = () => {
              width = canvas.width = window.innerWidth;
              height = canvas.height = window.innerHeight;
          };
          window.addEventListener('resize', handleResize);

          let time = 0;
          const points = [];
          const gridSize = 15;
          
          let numPointsX = Math.floor(width / gridSize);
          let numPointsY = Math.floor(height / gridSize);

          const initializePoints = () => {
              points.length = 0; // Clear existing points
              numPointsX = Math.floor(width / gridSize);
              numPointsY = Math.floor(height / gridSize);
              for (let i = 0; i < numPointsX; i++) {
                for (let j = 0; j < numPointsY; j++) {
                  points.push({
                    x: i * gridSize + gridSize / 2,
                    y: j * gridSize + gridSize / 2,
                    baseX: i * gridSize + gridSize / 2,
                    baseY: j * gridSize + gridSize / 2,
                  });
                }
              }
          }

          initializePoints();
          window.addEventListener('resize', initializePoints);


          const animate = () => {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, width, height);

            time += 0.01 * speed;

            points.forEach((point, index) => {
              // Calculate distance from multiple wave sources that move over time
              const source1X = width * 0.3 + Math.sin(time * 0.7) * 100;
              const source1Y = height * 0.5 + Math.cos(time * 0.5) * 100;
              const source2X = width * 0.7 + Math.cos(time * 0.6) * 100;
              const source2Y = height * 0.5 + Math.sin(time * 0.4) * 100;
              const source3X = width * 0.5;
              const source3Y = height * 0.3 + Math.sin(time * 0.8) * 80;

              const dist1 = Math.sqrt((point.baseX - source1X) ** 2 + (point.baseY - source1Y) ** 2);
              const dist2 = Math.sqrt((point.baseX - source2X) ** 2 + (point.baseY - source2Y) ** 2);
              const dist3 = Math.sqrt((point.baseX - source3X) ** 2 + (point.baseY - source3Y) ** 2);

              // Wave interference pattern
              const wave1 = Math.sin(dist1 * 0.02 * frequency1 - time * 3) * amplitude;
              const wave2 = Math.sin(dist2 * 0.02 * frequency2 - time * 2.5) * amplitude;
              const wave3 = Math.cos(dist3 * 0.015 * (frequency1 + frequency2) / 2 - time * 2) * amplitude * 0.7;

              const interference = (wave1 + wave2 + wave3) / 2;

              // Apply displacement based on interference
              point.x = point.baseX + Math.cos(interference * Math.PI) * 5;
              point.y = point.baseY + Math.sin(interference * Math.PI) * 5;

              // Calculate color based on interference and position
              const hue = (interference * 120 + 180 + time * 20) % 360;
              const saturation = 50 + interference * 30;
              const lightness = 50 + interference * 25;
              const opacity = 0.3 + Math.abs(interference) * 0.7;

              // Draw the point
              ctx.beginPath();
              ctx.arc(point.x, point.y, 2 + Math.abs(interference) * 3, 0, Math.PI * 2);
              ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${opacity})`;
              ctx.fill();

              // Draw connections to nearby points to create a "field" effect
              if (index % numPointsY !== 0) { // Check if not the first point in a column
                const prevPoint = points[index - 1];
                const connectionStrength = Math.abs(interference);
                if (connectionStrength > 0.3) {
                  ctx.beginPath();
                  ctx.moveTo(point.x, point.y);
                  ctx.lineTo(prevPoint.x, prevPoint.y);
                  ctx.strokeStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${opacity * 0.3})`;
                  ctx.lineWidth = connectionStrength;
                  ctx.stroke();
                }
              }

              if (index >= numPointsY) { // Check if not in the first row
                const prevPoint = points[index - numPointsY];
                const connectionStrength = Math.abs(interference);
                if (connectionStrength > 0.3) {
                  ctx.beginPath();
                  ctx.moveTo(point.x, point.y);
                  ctx.lineTo(prevPoint.x, prevPoint.y);
                  ctx.strokeStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${opacity * 0.3})`;
                  ctx.lineWidth = connectionStrength;
                  ctx.stroke();
                }
              }
            });

            animationRef.current = requestAnimationFrame(animate);
          };

          animate();

          return () => {
            if (animationRef.current) {
              cancelAnimationFrame(animationRef.current);
            }
            window.removeEventListener('resize', handleResize);
            window.removeEventListener('resize', initializePoints);
          };
        }, [frequency1, frequency2, amplitude, speed]); // Rerun effect when these change

        return (
          <div className="relative w-full h-screen bg-black overflow-hidden font-sans">
            <canvas
              ref={canvasRef}
              className="absolute inset-0"
            />

            {/* Controls Toggle Button */}
            <div className="absolute top-4 left-4 z-10">
              <button
                onClick={() => setShowControls(!showControls)}
                className="bg-white/10 backdrop-blur-md text-white px-4 py-2 rounded-lg hover:bg-white/20 transition-colors focus:outline-none focus:ring-2 focus:ring-white/50"
              >
                {showControls ? 'Hide' : 'Show'} Controls
              </button>
            </div>

            {/* Controls Panel */}
            {showControls && (
              <div className="absolute bottom-8 left-1/2 transform -translate-x-1/2 z-10 bg-black/30 backdrop-blur-md rounded-2xl p-6 space-y-4 min-w-[300px] md:min-w-[400px] border border-white/10 shadow-2xl">
                <h3 className="text-white text-lg font-semibold mb-4 text-center">Harmonic Resonance Field</h3>

                <div className="space-y-4">
                  <div>
                    <label className="text-white/80 text-sm">Wave Frequency α: {frequency1.toFixed(1)}</label>
                    <input
                      type="range"
                      min="1"
                      max="10"
                      step="0.1"
                      value={frequency1}
                      onChange={(e) => setFrequency1(parseFloat(e.target.value))}
                      className="w-full mt-1 accent-purple-500"
                    />
                  </div>

                  <div>
                    <label className="text-white/80 text-sm">Wave Frequency β: {frequency2.toFixed(1)}</label>
                    <input
                      type="range"
                      min="1"
                      max="10"
                      step="0.1"
                      value={frequency2}
                      onChange={(e) => setFrequency2(parseFloat(e.target.value))}
                      className="w-full mt-1 accent-blue-500"
                    />
                  </div>

                  <div>
                    <label className="text-white/80 text-sm">Amplitude: {amplitude.toFixed(2)}</label>
                    <input
                      type="range"
                      min="0.1"
                      max="1"
                      step="0.05"
                      value={amplitude}
                      onChange={(e) => setAmplitude(parseFloat(e.target.value))}
                      className="w-full mt-1 accent-green-500"
                    />
                  </div>

                  <div>
                    <label className="text-white/80 text-sm">Animation Speed: {speed.toFixed(1)}x</label>
                    <input
                      type="range"
                      min="0"
                      max="3"
                      step="0.1"
                      value={speed}
                      onChange={(e) => setSpeed(parseFloat(e.target.value))}
                      className="w-full mt-1 accent-orange-500"
                    />
                  </div>
                </div>

                <div className="text-white/60 text-xs mt-4 italic text-center">
                  Watch as harmonic waves create interference patterns,
                  forming a living mathematical tapestry.
                </div>
              </div>
            )}

            {/* Title & Formula */}
            <div className="absolute top-8 right-8 text-right pointer-events-none">
              <h1 className="text-white/90 text-3xl font-light tracking-wider">
                Harmonic Resonance
              </h1>
              <p className="text-white/50 text-sm mt-2">
                {`\\(f(x,y,t) = \\sum_{i=1}^{3} A_i \\sin(\\omega_i d_i - \\phi_i t)\\)`}
              </p>
            </div>
          </div>
        );
      };

      const container = document.getElementById('root');
      const root = ReactDOM.createRoot(container);
      root.render(<HarmonicResonanceField />);
    </script>
</body>
</html>
